function runExtendedSearchQuery(searchStr, fuse) {
  // https://fusejs.io/examples.html#weighted-search
  // we search for words that include searchStr and escape white space with double quotes
  // ex. "jesus christ"
  const startsWith = fuse.search(`^"${searchStr}"`);
  const includes = fuse.search(`'" ${searchStr}"`);
  const includes2 = fuse.search(`'"${searchStr}"`);

  // -----------------------------------------------------------------------
  // filter results including match by extended search type, then by score |
  // -----------------------------------------------------------------------
  const resultsDupes = [...startsWith, ...includes, ...includes2];

  // we want to
  // 1. remove duplicates
  // 2. barber should highlight ·∏áar·∏áer instead of ·∏áarber, so we override value
  const resultsDeduped = new Map();
  resultsDupes.forEach((item) => {
    resultsDeduped.set(item.refIndex, item);
  });

  // console.log([...resultsDeduped.values()].length);
  return [...resultsDeduped.values()];
}

function loadResults(searchQuery, PAGINATE_AMT) {
  let isFirstResult = searchQuery.i === 0;

  searchQuery.results.slice(searchQuery.i, searchQuery.i + PAGINATE_AMT).forEach((result) => {
    // console.log(result.refIndex);
    // if (result.refIndex !== 1904) {
    //   // testing '‹ò‹ø' occurring twice in same word, resulting in appending numerous
    //   // console.log('hello');
    //   return;
    // }
    // if (result.refIndex !== 4907) {
    //   // testing unvocalized '‹ê' being highlighted in numerous places
    //   // console.log('hello');
    //   return;
    // }
    // console.log(isFirstResult);
    // console.log(result);

    const aiiFragment = $('<div/>', { class: 'aii-verse' });
    let aiiHighlightedFragment;
    const trFragment = $('<div/>', { class: 'aii-tr' });
    let trHighlightedFragment;
    const engFragment = $('<div/>', { class: 'eng-verse' });
    let engHighlightedFragment;

    const DEBUG_HIGHLIGHT = false;
    if (DEBUG_HIGHLIGHT === false) {
      result.matches.forEach((match) => {
        if (match.key === 'tr') {
          trHighlightedFragment = highlightEngIndices(result.item.tr, match.indices);
        } else if (match.key === 'eng') {
          engHighlightedFragment = highlightEngIndices(result.item.eng, match.indices);
        } else if (match.key === 'aii' || match.key === 'aii_strip') {
          const re = match.key === 'aii' ? wordRegexAiiV(searchQuery.aii_v_query) : wordRegexAiiNotV(searchQuery.aii_not_v_query);

          aiiHighlightedFragment = regexHighlight(result.item.aii, re, 'highlighted');

          const paddedAii = padAiiV(result.item.aii, re);
          const paddedTr = aiiTranslit(paddedAii).phonetic;
          trHighlightedFragment = highlightPaddedTr(paddedTr);
        }
      });
    }

    if (aiiHighlightedFragment === undefined) {
      aiiFragment.text(result.item.aii);
    } else {
      aiiFragment.append(aiiHighlightedFragment);
    }

    if (isFirstResult) {
      if (trHighlightedFragment !== undefined) {
        trFragment.append(
          $('<div/>').append(trHighlightedFragment),
        );
      } else {
        trFragment.append($('<div/>', { text: result.item.tr }));
      }
      trFragment.append(
        $('<div/>', { class: 'tr-backlink-container' }).append(
          $('<span/>', { class: 'webapp-backlink-meta', text: '^ generated by üß† ' }),
          $('<a/>', { class: 'webapp-backlink-href', href: '../assyrian-transliterator/', text: 'Assyrian Transliterator' }),
        ),
      );
      isFirstResult = false;
    } else if (trHighlightedFragment === undefined) {
      trFragment.text(result.item.tr);
    } else {
      trFragment.append(trHighlightedFragment);
    }

    if (result.item.eng === null) {
      engFragment.addClass('missing-verse');
    } else if (engHighlightedFragment === undefined) {
      engFragment.text(result.item.eng);
    } else {
      engFragment.append(
        engHighlightedFragment,
      );
    }

    $('#search-results').append(
      $('<div/>', { class: 'search-result' }).append(
        $('<div/>', { class: 'verse-meta' }).append(
          $('<a/>', {
            text: `${bookDisplayName[result.item.book][1]} ${result.item.chapter}‚Äè:${result.item.verse}`,
            href: `../assyrian-bible/?book=${result.item.book}&chapter=${result.item.chapter}:${result.item.verse}`,
          }),
        ),
        aiiFragment,
        trFragment,
        engFragment,
      ),
    );
    // console.log(result.item);
  });

  // eslint-disable-next-line no-param-reassign
  searchQuery.i += PAGINATE_AMT;
}

function highlightEngIndices(s, indices) {
  // const indicies = [[0, 1], [3, 6]];
  // https://stackoverflow.com/a/42357954
  const fragment = $(document.createDocumentFragment());
  let i = 0;

  indices.forEach((index) => {
    const [start, end] = index;
    if (start > i) {
      // test case - match starts at i = 0
      fragment.append(
        $('<span/>', { text: s.slice(i, start) }),
      );
    }
    fragment.append(
      $('<span/>', { class: 'highlighted', text: s.slice(start, end + 1) }),
    );
    i = end + 1;
  });
  if (i < s.length) {
    fragment.append(
      $('<span/>', { text: s.slice(i, s.length) }),
    );
  }
  return fragment;
}

// i = 0
// [1, 3], [42, 54]
//  i
// -***------
// 0123456789

function wordRegexAiiV(aiiVQuery) {
  const firstChar = aiiVQuery[0];
  const lastChar = aiiVQuery.slice(-1);

  // conditionals safeguard against aiiVQuery padded with spaces or a punctuation marks
  let captureGroup = '(';
  if (AiiUtils.atLeastOneAiiVChar(firstChar)) {
    captureGroup += `${AiiUtils.aiiVCharClass}*`;
  }
  captureGroup += aiiVQuery;
  if (AiiUtils.atLeastOneAiiVChar(lastChar)) {
    captureGroup += `${AiiUtils.aiiVCharClass}*`;
  }
  captureGroup += ')';

  return new RegExp(captureGroup, 'g');
}

function wordRegexAiiNotV(aiiNotVQuery) {
  // ‹ê ‹í ‹ì ‹ï
  const firstChar = aiiNotVQuery[0];
  const lastChar = aiiNotVQuery.slice(-1);

  // conditionals safeguard against aiiNotVQuery padded with spaces or a punctuation marks
  let captureGroup = '(';
  if (AiiUtils.atLeastOneAiiLetter(firstChar)) {
    captureGroup += `${AiiUtils.aiiVCharClass}*`;
  }
  const aiiChars = aiiNotVQuery.split('');
  const sandwich = aiiChars.join(`${AiiUtils.diacriticCharClass}*`);
  captureGroup += sandwich;
  if (AiiUtils.atLeastOneAiiLetter(lastChar)) {
    captureGroup += `${AiiUtils.aiiVCharClass}*`;
  }
  captureGroup += ')';

  return new RegExp(captureGroup, 'g');
}

function regexHighlight(s, re, highlightClass) {
  const fragment = $(document.createDocumentFragment());
  let i = 0;
  s.replace(re, (match, $1, start) => {
    // https://stackoverflow.com/a/49262416
    if (start > i) {
      // test case - match starts at i = 0
      fragment.append(
        $('<span/>', { text: s.slice(i, start) }),
      );
    }
    fragment.append(
      $('<span/>', { class: highlightClass, text: $1 }),
    );
    i = start + match.length;
    // Return the replacement leveraging the parameters.
  });
  if (i < s.length) {
    fragment.append(
      $('<span/>', { text: s.slice(i, s.length) }),
    );
  }

  return fragment;
}

function padAiiV(aiiV, re) {
  // takes an aii string and pads the matching words w/ delimiters
  const sDelimiter = ' ‚ùã '; // we use uncommon dingbat
  const eDelimiter = ' ‚ùä '; // we use uncommon dingbat
  return aiiV.replaceAll(re, `${sDelimiter}$1${eDelimiter}`);
}

function highlightPaddedTr(tr) {
  const sDelimiter = ' ‚ùã '; // we use uncommon dingbat
  const eDelimiter = ' ‚ùä '; // we use uncommon dingbat

  const re = new RegExp(`${sDelimiter}(.*?)${eDelimiter}`, 'g');
  return regexHighlight(tr, re, 'highlighted2');
}
